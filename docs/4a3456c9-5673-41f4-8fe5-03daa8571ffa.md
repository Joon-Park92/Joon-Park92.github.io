---
publish: true
uuid: 4a3456c9-5673-41f4-8fe5-03daa8571ffa
---

# 프롬프트 엔지니어링 모범 사례 (25.03.25 기준)

프롬프트 엔지니어링이란 **AI 언어 모델에게 원하는 결과물을 얻기 위해 프롬프트(명령어)를 설계**하는 기술입니다. 효과적인 프롬프트를 작성하면 모델의 응답 정확성과 일관성을 크게 높일 수 있습니다. 아래에서는 한국어 작업을 중심으로, 일반적인 프롬프트 설계 전략과 작업 유형별 차이, 모델 버전별 특성에 따른 프롬프트 최적화, 동일 프롬프트에 대한 예측 불가능성 대응, 그리고 실패하기 쉬운 프롬프트 예시와 개선안을 살펴보겠습니다.

## 1. 효과적인 프롬프트 설계 일반 원칙

AI에게 기대하는 결과를 얻으려면 **프롬프트 자체를 명확하고 구체적으로 작성**해야 합니다. 다음은 공통적으로 적용되는 프롬프트 작성 모범 사례입니다.

- **명확하고 구체적인 지시:** 모델이 **명확하게 이해할 수 있는 지침**을 제공합니다. 원하는 작업과 범위를 분명히 하여 AI가 혼동하지 않도록 합니다 ([프롬프트 엔지니어링이란 무엇인가요? (기본 사항 및 모범 사례)](https://textcortex.com/ko/post/what-is-prompt-engineering#:~:text=%EC%A7%81%EC%A0%91%EC%A0%81%EC%9D%B4%EA%B3%A0%20%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0%20%EC%89%AC%EC%9A%B4%20%EC%A7%80%EC%B9%A8%20%EB%A7%8C%EB%93%A4%EA%B8%B0)) ([프롬프트 엔지니어링이란? - AI 프롬프트 엔지니어링 설명 - AWS](https://aws.amazon.com/ko/what-is/prompt-engineering/#:~:text=%EB%AA%A8%ED%98%B8%ED%95%98%EC%A7%80%20%EC%95%8A%EC%9D%80%20%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8)). 예를 들어 단순히 “요약해줘”라고 하기보다는 **“다음 글을 3문장으로 요약해줘”**와 같이 *무엇을 어떻게* 해야 하는지 구체적으로 지시합니다. 요청이 모호하면 모델 역시 모호한 답을 내놓기 쉽습니다. 따라서 작업 종류(요약, 번역 등)와 원하는 산출물 형태를 명시해야 합니다. **모델에게 무엇을 하지 말라는 부정형 지시보다, 무엇을 해야 하는지 긍정형으로 제시**하는 것이 효과적입니다 ([11 prompting tips to make GPT-3.5 as good as GPT-4](https://www.vellum.ai/blog/prompt-engineering-tips-to-boost-gpt-3-5-to-gpt-4-level#:~:text=First%20and%20foremost%2C%20your%20prompt,needs%20to%20be%20very%20specific)). 예를 들어 “원문에 없는 내용은 쓰지 마세요”보다는 “**원문에 제시된 정보만 활용하세요**”라고 하는 편이 좋습니다.

- **프롬프트에 맥락과 정보 제공:** **필요한 배경정보나 조건**이 있다면 프롬프트에 포함시킵니다. 모델은 주어진 정보만 토대로 답하기 때문에, 추가로 참고해야 할 자료나 사실이 있다면 함께 제공하는 것이 정확성을 높입니다. 예를 들어 질문 자체가 막연하거나 사실관계를 알아야 해결되는 경우, **관련 텍스트, 데이터, URL 등을 함께 제시**하면 모델이 추측으로 채우는 것을 줄일 수 있습니다 ([프롬프트 엔지니어링이란 무엇인가요? (기본 사항 및 모범 사례)](https://textcortex.com/ko/post/what-is-prompt-engineering#:~:text=%EC%B6%A9%EB%B6%84%ED%95%9C%20%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4%20%EA%B3%B5%EA%B8%89)). 필요한 경우 모델이 답변에 활용해야 하는 **구체적 자료나 예시도 프롬프트에 포함**하는 것이 좋습니다. 이러한 **맥락(Context)** 제공은 엉뚱한 답변이나 환각(hallucination)을 줄이고 모델의 출력을 원하는 방향으로 이끌어 줍니다 ([프롬프트 엔지니어링이란 무엇인가요? (기본 사항 및 모범 사례)](https://textcortex.com/ko/post/what-is-prompt-engineering#:~:text=%EC%B6%A9%EB%B6%84%ED%95%9C%20%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4%20%EA%B3%B5%EA%B8%89)).

- **예시와 역할 활용:** **Few-shot 예시**(몇 가지 입력-출력 예를 제공)나 **역할 지시**를 통해 모델이 답해야 할 **형식과 톤을 학습**시킬 수 있습니다. 예시를 통해 원하는 출력 형태를 보여주면 모델이 그 패턴을 따라가기 때문에, 특히 출력 형식이나 어조가 중요할 때 유용합니다 ([11 prompting tips to make GPT-3.5 as good as GPT-4](https://www.vellum.ai/blog/prompt-engineering-tips-to-boost-gpt-3-5-to-gpt-4-level#:~:text=8)). 예를 들어 *고객 서비스 답변*을 원한다면 두어 개의 모범 답변 예시를 제시하고 “이제 환불 지연 문의에 대한 답장을 작성해줘”라고 하면 모델이 유사한 어조로 답합니다 ([Mastering Prompt Engineering: Best Practices, Do's and Don'ts](https://www.linkedin.com/pulse/mastering-prompt-engineering-best-practices-dos-donts-lucca-sehn-nmiqf#:~:text=Few)) ([Mastering Prompt Engineering: Best Practices, Do's and Don'ts](https://www.linkedin.com/pulse/mastering-prompt-engineering-best-practices-dos-donts-lucca-sehn-nmiqf#:~:text=Write%20a%20polite%20response%20to,their%20shipment%20has%20been%20delayed)). 또한 **모델에 역할을 부여**하면 톤이나 전문성이 더 잘 맞춰집니다. 예를 들어 “당신은 전문 번역가입니다. 다음 문장을 번역하세요:”처럼 시작하면 전문적인 번역 투로 응답할 가능성이 높습니다. 마찬가지로 “당신은 5살 아이에게 설명하듯이…”와 같이 **대상 독자나 말투를 지정**하면 답변 스타일을 제어할 수 있습니다 ([Mastering Prompt Engineering: Best Practices, Do's and Don'ts](https://www.linkedin.com/pulse/mastering-prompt-engineering-best-practices-dos-donts-lucca-sehn-nmiqf#:~:text=As%20a%20software%20engineer%20explaining,world%20examples)).

- **복잡한 작업은 단계적으로:** 요청 내용이 복잡하거나 여러 단계를 포함한다면 **문제를 쪼개어 단계별로 지시**합니다. 한 번에 복잡한 지시를 길게 내리는 것보다, 논리적인 순서로 한 단계씩 요구하는 편이 모델이 따라오기 쉽습니다 ([프롬프트 엔지니어링이란 무엇인가요? (기본 사항 및 모범 사례)](https://textcortex.com/ko/post/what-is-prompt-engineering#:~:text=%EB%B3%B5%EC%9E%A1%ED%95%9C%20%EC%9E%91%EC%97%85%20%EC%84%B8%EB%B6%84%ED%99%94)). 예를 들어 “다음 글의 핵심 주제를 찾아 요약한 뒤, 그에 대한 의견을 제시하라”는 프롬프트는 한번에 두 가지 일을 요구합니다. 이 경우 “1단계: 글의 핵심 주제를 한 문장으로 표현하세요. 2단계: 해당 주제에 대한 의견을 세 줄로 쓰세요.”처럼 **중간 출력**를 거쳐 최종 답을 작성하게 유도할 수 있습니다. 이러한 **Chain-of-Thought(사고 사슬)** 방식은 모델의 복잡한 문제 해결 능력을 향상시키는 것으로 알려져 있습니다 ([프롬프트 엔지니어링이란? - AI 프롬프트 엔지니어링 설명 - AWS](https://aws.amazon.com/ko/what-is/prompt-engineering/#:~:text=match%20at%20L213%20%EC%82%AC%EA%B3%A0%EC%9D%98%20%EC%82%AC%EC%8A%AC,%EC%9D%B4%EB%8A%94%20%EC%B6%94%EB%A1%A0%20%EB%8A%A5%EB%A0%A5%EC%9D%84%20%EB%86%92%EC%9E%85%EB%8B%88%EB%8B%A4)). 즉, *“생각을 단계별로 진행해보자”*라고 유도하면 모델이 바로 답을 내기보다 추론 과정을 거쳐 더 논리적인 결과를 산출할 수 있습니다.

- **출력 형식과 제약 조건 명시:** 모델이 답변을 어떤 형태로 주길 바라는지 **명확히 규정**해야 합니다. 예컨대, 한글로 답해야 하는지, 목록이나 표 형식으로 정리해야 하는지, 글자/단어 수 제한이 있는지 등을 프롬프트에 포함합니다 ([프롬프트 엔지니어링이란? - AI 프롬프트 엔지니어링 설명 - AWS](https://aws.amazon.com/ko/what-is/prompt-engineering/#:~:text=%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8%20%EB%82%B4%EC%9D%98%20%EC%A0%81%EC%A0%88%ED%95%9C%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8)). *“표 형태로 1990년대 인기 영화 5편을 알려줘”*라고 하면 영화 5편을 표로 만들어 주겠지만, 그냥 “1990년대 인기 영화 알려줘”라고 하면 서술 형태의 답이 나올 수 있습니다 ([프롬프트 엔지니어링이란? - AI 프롬프트 엔지니어링 설명 - AWS](https://aws.amazon.com/ko/what-is/prompt-engineering/#:~:text=%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8%20%EB%82%B4%EC%9D%98%20%EC%A0%81%EC%A0%88%ED%95%9C%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8)). 마찬가지로 *“300자 이내로 답해주세요”*처럼 **길이 제한**을 두거나, *“한 문단으로”*, *“불릿 목록으로”* 등의 형식 지시를 내릴 수 있습니다. 가능한 한 **구체적인 형식 예시**를 보여주면 더욱 정확한 출력을 얻을 수 있습니다.

이러한 원칙들을 종합하면, 좋은 프롬프트는 **무엇을(내용), 어떻게(형식/톤), 어느 정도로(분량 등)** 해야 하는지를 모두 포함합니다. 예를 들어 아래는 여러 지침을 조합한 프롬프트 사례입니다:

> **예시:** 지속 가능한 에너지 솔루션을 주제로 **전문적인 어조로 간결한 요약**을 작성하세요. **요약은 300단어를 넘지 않아야** 합니다. **태양광 및 풍력 발전의 최신 동향**을 포함해야 하며, **IEA(국제에너지기구) 2023 보고서의 최근 통계**를 반드시 인용해야 합니다. **출력 형식은 불릿포인트 목록**이어야 합니다 ([프롬프트 엔지니어링이란 무엇인가요? (기본 사항 및 모범 사례)](https://textcortex.com/ko/post/what-is-prompt-engineering#:~:text=%EC%A7%80%EC%86%8D%20%EA%B0%80%EB%8A%A5%ED%95%9C%20%EC%97%90%EB%84%88%EC%A7%80%20%EC%86%94%EB%A3%A8%EC%85%98%EC%9D%84%20%EC%A3%BC%EC%A0%9C%EB%A1%9C,%EC%B6%9C%EB%A0%A5%20%ED%98%95%EC%8B%9D%EC%9D%80%20%EB%B6%88%EB%A6%BF%ED%8F%AC%EC%9D%B8%ED%8A%B8%20%EB%AA%A9%EB%A1%9D%EC%9D%B4%EC%96%B4%EC%95%BC%20%ED%95%A9%EB%8B%88%EB%8B%A4)).

위 프롬프트는 *주제와 어조, 분량 제한, 포함할 구체 정보, 형식*까지 명시하고 있어, 모델이 출력할 내용과 범위를 정확히 이해할 수 있는 모범 사례입니다. 실제로 이러한 방식으로 **직접적이고 상세한 지침을 주면 원하는 결과를 얻을 가능성이 매우 높아집니다 ([프롬프트 엔지니어링이란 무엇인가요? (기본 사항 및 모범 사례)](https://textcortex.com/ko/post/what-is-prompt-engineering#:~:text=%EC%A7%81%EC%A0%91%EC%A0%81%EC%9D%B4%EA%B3%A0%20%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0%20%EC%89%AC%EC%9A%B4%20%EC%A7%80%EC%B9%A8%20%EB%A7%8C%EB%93%A4%EA%B8%B0))**.

또한 **프롬프트 엔지니어링은 반복적인 실험 과정**임을 기억하세요. 한 번에 완벽한 프롬프트를 만들기 어려우므로, 결과를 보면서 조금씩 수정하고 보완해 나갑니다 ([프롬프트 엔지니어링이란? - AI 프롬프트 엔지니어링 설명 - AWS](https://aws.amazon.com/ko/what-is/prompt-engineering/#:~:text=%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8%20%EC%8B%A4%ED%97%98%20%EB%B0%8F%20%EA%B0%9C%EC%84%A0)). 여러 phrasing을 시도해 보고, 모델 응답이 기대와 다르면 프롬프트를 조정하여 **지속적으로 개선**하는 것이 중요합니다. 이렇게 하면 프롬프트를 더 짧고 효과적으로 다듬을 수도 있고, 모델이 점점 더 일관된 결과를 내도록 유도할 수 있습니다 ([프롬프트 엔지니어링이란? - AI 프롬프트 엔지니어링 설명 - AWS](https://aws.amazon.com/ko/what-is/prompt-engineering/#:~:text=%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8%20%EC%8B%A4%ED%97%98%20%EB%B0%8F%20%EA%B0%9C%EC%84%A0)).

## 2. 작업 유형별 프롬프트 설계의 차이점

프롬프트 설계는 **수행하려는 작업(Task)**에 따라 조금씩 접근법을 달리하면 효과적입니다. 요약, 번역, 분류, 코드 생성, 창작 등 대표적인 작업별로 **유의해야 할 프롬프트 작성 요령**을 살펴보겠습니다.

### 요약 (Summarization)

텍스트 요약을 지시할 때는 **요약 대상과 원하는 요약의 특성**을 명확히 해야 합니다. 우선 **요약할 원문 텍스트를 모델에 제공**하거나, 이미 대화 맥락에 해당 텍스트가 주어져 있어야 합니다. 그 후에 **“~을 요약해줘”**라고 요청하되, 가능하면 **요약의 형태나 길이를 지정**하는 것이 좋습니다. 예를 들어 *“위 글의 주요 내용을 한 문장으로 요약해주세요”*, *“다음 기사 내용을 세 줄로 요약해줘”*처럼 **문장 수나 분량, 문체**를 지정하면 모델이 어느 정도로 압축해야 할지 판단하기 쉽습니다 ([Compilation of prompt engineering basic rules : r/ChatGPTPromptGenius](https://www.reddit.com/r/ChatGPTPromptGenius/comments/13vyz0u/compilation_of_prompt_engineering_basic_rules/#:~:text=Summarize%20the%20following%20news%20article%3A)). 실제 AWS의 Titan 모델 예시를 보면, 사용자 프롬프트에서 리뷰 전문을 제공한 뒤 *“Summarize the above restaurant review in one sentence.”*라고 지시하였고, 모델은 해당 리뷰를 한 문장으로 간결하게 응답했습니다 ([프롬프트란 무엇인가요? - Amazon Bedrock](https://docs.aws.amazon.com/ko_kr/bedrock/latest/userguide/what-is-a-prompt.html#:~:text=Summarize%20the%20above%20restaurant%20review,in%20one%20sentence)). 이처럼 **한글 요약**에서도 *“한 문장으로 요약”*, *“간단히 핵심만 요약”*, *“~목록으로 요약”* 등의 요구사항을 덧붙이세요. 또한 **원문에서 벗어나지 않는 요약**을 원한다면 *“원문에 충실하게”* 혹은 *“추가적인 해석이나 의견 없이”* 등의 문구로 제한을 거는 것도 도움이 됩니다.

### 번역 (Translation)

번역 작업용 프롬프트에서는 **번역할 대상 텍스트**와 **목표 언어**를 반드시 명시합니다. 예컨대 *“번역해줘”*라고만 하면 어떤 언어로 어떻게 번역해야 할지 불분명하므로 실패하기 쉽습니다. 대신 *“다음 문장을 영어로 번역해줘: '...'”*, *“이 문단을 한국어로 번역해줘”*처럼 **원문과 번역 방향**을 정확히 알려주세요. 한국어 번역의 경우 **존댓말/반말**이나 **격식**도 원하는 대로 지정할 수 있습니다. 예를 들어 *“아래 영문 텍스트를 한국어 반말로 자연스럽게 번역해줘.”*, *“다음을 비즈니스 문서에 어울리는 격식체로 번역해주세요.”* 같이 말입니다. 이렇게 하면 모델이 단순 직역이 아닌, **맥락과 용도에 맞는 번역체**를 만들어냅니다. 또한 번역할 때 **용어 통일이나 이름 고유명사 표기법** 등이 있다면 프롬프트에 설명해 주는 것이 좋습니다. 예를 들어 *“전문 용어는 가능한 한 음역하지 말고 뜻을 풀어써줘”* 또는 *“인명은 성과 이름을 그대로 음역해줘”* 등의 지침을 줄 수 있습니다. 마지막으로, 긴 문장을 번역할 때는 문장 단위로 나눠서 번역을 요청하거나, 한 번에 너무 많은 텍스트를 주지 않도록 유의합니다 (모델의 입력 용량 한계가 있기 때문입니다).

### 분류 (Classification)

분류 작업의 프롬프트는 **무엇을 어떤 기준으로 분류해야 하는지**를 분명히 알려야 합니다. 먼저 **분류 대상**(예: 문장, 리뷰, 이메일 등)을 제시하고, **분류 라벨**을 정의해주는 것이 핵심입니다. 예를 들어 감정 분석이라면 *“이 문장을 긍정 또는 부정으로 분류해줘”*, 스팸 검출이라면 *“다음 이메일이 스팸인지 아닌지 분류해줘”*처럼 **가능한 카테고리를 명시**합니다. 분류 기준이 모호하지 않도록, 필요하다면 각 라벨의 의미나 예시를 간략히 덧붙이는 것도 좋습니다 (*“긍정(예: 만족했다, 좋았다), 부정(예: 불만이다, 나빴다)”* 식으로). 모델이 **한 가지 레이블만 답하도록 유도**하려면 답변 형식을 제한합니다. *“긍정/부정 중 하나로만 답하세요”*처럼 말이죠. 가능하면 **불필요한 설명을 하지 말고 레이블만 출력**하도록 요구하세요. 이렇게 하면 분류 결과를 후처리하기도 수월합니다. 참고로, 분류 작업은 창의성보다는 **일관성과 정확성**이 중요하므로, OpenAI API 등을 사용할 땐 `temperature` 파라미터를 0으로 낮춰 **출력의 무작위성을 최소화**하는 것이 권장됩니다 ([Design text prompts  |  Generative AI  |  Google Cloud](https://cloud.google.com/vertex-ai/generative-ai/docs/text/text-prompts#:~:text=Best%20practices%20for%20classification%20prompts)). ChatGPT 인터페이스에서는 사용자가 직접 파라미터를 바꿀 수는 없지만, 프롬프트를 통해 *“정확한 답변만 간결히”*라고 강조하면 모델이 불필요한 변주 없이 답하도록 유도할 수 있습니다.

### 코드 생성 (Code Generation)

프로그래밍 코드 생성을 위한 프롬프트를 작성할 때는 **정확히 어떤 코드가 필요한지 상세히** 알려주는 것이 중요합니다. 우선 **사용할 프로그래밍 언어**를 명시하세요 (*“파이썬 코드로 보여줘”*, *“자바스크립트 코드 예시”* 등). 모델은 언어 지시가 없으면 기본적으로 파이썬 등으로 추측해 작성하곤 하므로, 원하는 언어가 있다면 반드시 지정해야 합니다. 다음으로, **해결하려는 문제나 구현할 기능을 구체적으로 설명**합니다. 예를 들어 *“2개의 숫자를 입력받아 더하는 함수 작성해줘”*, *“주어진 배열을 정렬하는 파이썬 코드 작성해줘”*처럼 요구사항을 정확히 제시합니다. 가능하면 **입출력 예시**나 **포함되어야 할 세부 조건**도 함께 주는 것이 좋습니다. *“예: 입력 [3,1,2] -> 출력 [1,2,3]”* 처럼 예시를 주면 모델이 해당 동작을 하는 코드를 작성하는 데 도움이 됩니다. 또한 **필요한 출력 형식**을 지정해 주세요. 코드만 필요한지, 아니면 설명이나 주석도 함께 필요한지 명확히 합니다. 예컨대 *“코드만 답변하고 설명은 필요 없어요”* 라고 하면 코드 블록만 출력하고 추가 설명을 생략합니다. 반대로 코드 동작 해설이 필요하면 *“코드와 함께 각 단계에 대한 주석을 달아줘”* 또는 *“마지막에 코드 설명도 덧붙여줘”*처럼 요구할 수 있습니다. 한편, 한국어로 프롬프트를 작성해도 모델은 요청대로 코드 생성이 가능하지만, **코드 자체는 기본적으로 영어 키워드**로 이루어지므로 (파이썬 등 대부분 언어가 영문 기반), 함수명이나 변수명을 한글로 짓지 않는 한 코드는 언어에 상관없이 출력됩니다. 필요하면 주석을 한글로 달도록 지시할 수도 있습니다 (*“# 주석은 한글로 달아주세요”*). 마지막으로, 생성된 코드가 긴 경우 모델이 중간에 출력 생략을 할 수 있으므로, *“하나의 답변에 전체 코드를 다 보여줘”*라고 언급하거나, 필요한 경우 코드를 부분별로 나눠 요청하는 것도 고려합니다. 코드 생성 후에는 **모델이 완벽한 코드를 보장하지 않으므로**, 프롬프트에서 *“버그가 없도록 주의”* 등의 당부를 하더라도 사용자가 결과 코드를 검증하고 테스트하는 과정은 여전히 필요합니다.

### 창작 및 글쓰기 (Creative Writing)

에세이, 소설, 시, 광고 카피 등 **창작 작업**에 대한 프롬프트는 **명확한 지침**과 **창의적 자유**의 균형을 맞추는 것이 중요합니다. 우선 원하는 글의 **형식과 톤, 주제**를 프롬프트에 명시합니다. 예를 들어 *“동화 형식으로, 유머러스한 톤으로 어린이를 위한 짧은 이야기 만들어줘”*, *“미래 서울을 배경으로 한 SF 소설 줄거리를 개요 형태로 작성해줘”*처럼 **장르, 분위기, 대상 독자, 길이** 등을 지정할 수 있습니다. 이렇게 하면 모델이 글쓰기의 **방향성을 이해**하는 데 도움이 됩니다. 동시에, 창작 영역에서는 너무 세세하게 지시하기보다 **어느 정도 자유도**를 주는 편이 더 풍부한 결과를 얻기도 합니다. 예를 들어 캐릭터나 줄거리의 큰 틀만 제시하고 세부 전개는 모델에 맡긴다든지, 첫 문장만 제공하고 이어서 써 달라고 요청하는 방식입니다. *“첫 문장은 '어느 조용한 마을에 이상한 일이 벌어졌다.'입니다. 이어서 흥미진진한 미스터리 단편을 완성해주세요.”*라고 하면 모델이 이어서 창작할 것입니다. 또한 **예시나 참고 스타일**을 제시하면 도움이 됩니다. *“헤밍웨이 스타일로 글을 써줘”*, *“아이유 노래 가사처럼 감성적으로 써줘”* 등 특정 작가나 작품 스타일을 언급하면 어휘나 문체를 비슷하게 맞추려 시도합니다. 한국어 창작의 경우에도 **문체** (예: 문어체/구어체, 옛날한글체 등)를 지정하거나, **운율**이 필요한 시라면 *“4행시로”*, **대화체**라면 *“대본 형식으로”* 등 원하는 형식을 명시해야 합니다. 창작 결과에서 피하고 싶은 요소가 있다면 (예: 폭력적 내용 배제 등) 부정 지시 대신 *“따뜻하고 긍정적인 내용으로”*와 같이 긍정적으로 원하는 바를 설명합니다. 마지막 팁으로, 창작 프롬프트는 다양한 결과가 가능하기 때문에, **한 번의 시도로 만족스럽지 않으면 프롬프트를 약간 바꿔 여러 번 시도**해보세요. 모델은 매번 다른 전개나 표현을 내놓을 수 있으므로, 그 중에서 가장 마음에 드는 결과를 선택하거나, 여러 결과를 조합해 활용할 수도 있습니다.

## 3. 모델/버전별 응답 특성과 프롬프트 최적화

현재 사용되는 GPT 계열 모델에도 여러 버전이 있으며 (예: GPT-3.5, GPT-4 등), **모델마다 응답 특성에 차이**가 존재합니다. 따라서 최적의 결과를 얻기 위해서는 사용 중인 모델의 특성을 이해하고 프롬프트를 조정하는 것이 좋습니다.

**GPT-4**는 이전 버전들보다 **더 높은 언어 이해 능력과 추론 능력**을 갖춘 것으로 평가됩니다. OpenAI에 따르면 GPT-4는 **믿음직하고 창의적이며, 미묘한 지시도 더 잘 처리**하도록 설계되었습니다 ([GPT-3.5 vs. GPT-4: Biggest differences to consider | TechTarget](https://www.techtarget.com/searchenterpriseai/tip/GPT-35-vs-GPT-4-Biggest-differences-to-consider#:~:text=GPT,extended%20capabilities%20include%20the%20following)). 실제로 GPT-4는 복잡한 지시나 추론이 필요한 작업에서 보다 **깊이 있고 일관된 응답**을 생성하는 경향이 있습니다. 또한 **맥락을 파악하는 능력**이 뛰어나서, 긴 문맥이나 이전 대화 내용을 더 잘 활용합니다. GPT-4는 입력 토큰 수용량(컨텍스트 윈도우)이 GPT-3.5보다 훨씬 커서 최대 수만자에 이르는 긴 입력도 처리할 수 있습니다 ([GPT-3.5 vs. GPT-4: Biggest differences to consider | TechTarget](https://www.techtarget.com/searchenterpriseai/tip/GPT-35-vs-GPT-4-Biggest-differences-to-consider#:~:text=%2A%20Multimodality.%20GPT,conversations%2C%20and%20document%20search%20and)). 이것은 한 번에 많은 정보를 주고 요약하거나 대화 맥락을 길게 유지하는 데 유리합니다. 다만 GPT-4는 그만큼 **응답 생성 속도가 느리고**, API 사용 시 **비용이 높을 수** 있다는 현실적인 제약이 있습니다. 따라서 GPT-4를 활용할 때는 가능하면 **프롬프트를 간결하게 최적화**하여 중요 정보만 담고, 불필요한 토큰 낭비를 줄이는 것이 효율적입니다.

**GPT-3.5** (특히 GPT-3.5 Turbo 기반 모델)는 GPT-4에 비해 **응답이 빠르고 비용이 저렴**하지만, 복잡한 요구사항 처리나 창의적 응답 품질 면에서 다소 열위일 수 있습니다. 예컨대 GPT-3.5는 경우에 따라 지시를 부분적으로 놓치거나, 제한을 어긴 답변을 내는 등 **지시 준수 면에서 불안정**한 모습을 보이기도 합니다. 또한 동일한 프롬프트라도 GPT-4보다 출력 내용이 간략하거나 피상적으로 나올 때가 있습니다. 하지만 프롬프트를 잘 설계하면 GPT-3.5도 상당히 만족스러운 결과를 얻을 수 있습니다. **프롬프트 엔지니어링을 통해 GPT-3.5의 성능을 GPT-4에 준하는 수준으로 끌어올린 사례들도 보고**되고 있습니다 ([Comparing GPT-3.5 & GPT-4: A Thought Framework on When To Use Each Model](https://techcommunity.microsoft.com/blog/azure-ai-services-blog/comparing-gpt-3-5--gpt-4-a-thought-framework-on-when-to-use-each-model/4088645#:~:text=analysis%2C%20and%20classification%20workloads,learning%2C%20which%20use%20more%20tokens)). 단, 이를 위해서는 체인-of-Thought나 Few-shot 학습 등 **추가적인 기법과 더 많은 토큰 투입**이 필요할 때가 많습니다 ([Comparing GPT-3.5 & GPT-4: A Thought Framework on When To Use Each Model](https://techcommunity.microsoft.com/blog/azure-ai-services-blog/comparing-gpt-3-5--gpt-4-a-thought-framework-on-when-to-use-each-model/4088645#:~:text=analysis%2C%20and%20classification%20workloads,learning%2C%20which%20use%20more%20tokens)). 예를 들어 GPT-3.5는 복잡한 추론을 바로 하기는 어려워도, *“하나씩 단계별로 생각해봐”*라는 힌트를 주면 더 논리적인 답변을 만들 수 있습니다. 또는 간단한 예시 두어 개를 보여주고 나면 형식을 훨씬 잘 맞춰줍니다. 이런 식으로 **GPT-3.5는 명시적인 가이드가 있을 때 성능이 향상**되므로, **더 세밀하게 프롬프트를 작성**하거나 필요한 경우 **응답을 검증하는 추가 질문**을 이어서 하는 방식으로 활용합니다.

**모델 버전별 최적화 전략:** 우선 **가능하면 최신 모델**을 사용하는 것이 일반적으로 유리합니다 ([LLM Prompt Engineering Techniques and Best Practices | by Ali Shafique | Medium](https://medium.com/@alishafique3/llm-prompt-engineering-techniques-and-best-practices-7cc0f46467e9#:~:text=1)). 최신 버전일수록 개선된 이해도와 기능을 갖추고 있기 때문입니다. 예를 들어 동일한 요청에 대해 GPT-4는 특별한 기교 없이도 원하는 답을 줄 확률이 높지만, GPT-3.5에서는 비슷한 품질을 얻기 위해 **프롬프트를 좀 더 세밀하게 튜닝**해야 할 수 있습니다. 만약 두 모델을 모두 사용할 수 있는 상황이라면, **먼저 GPT-4로 프롬프트를 설계해 본 뒤**, 그 프롬프트를 GPT-3.5에 적용해보고 결과를 비교하는 방법도 있습니다. GPT-3.5에서 기대에 못 미치는 부분이 있다면 프롬프트에 **추가 지침이나 예시를 보강**해서 출력 격차를 줄일 수 있습니다. 또한 모델별로 특성을 알고 활용하면 좋은데, 예를 들어 GPT-4는 **장문 요약**이나 **복잡한 문법 이해**가 강점이므로 긴 문서를 한 번에 요약시키는 작업에 적합합니다. 반면 GPT-3.5는 **응답 속도**가 빠르므로 간단한 질의응답이나 **실시간 대화형** 응용에 적합합니다. 필요한 경우, **작업 종류에 따라 두 모델을 병행 활용**하는 것도 고려해볼 수 있습니다 (예: 초안 작성은 GPT-3.5로 빠르게 하고, 다듬기는 GPT-4로 시도).

요약하면, **GPT-4 vs GPT-3.5**를 사용할 때 프롬프트 작성의 기본 원칙은 비슷하지만, **GPT-3.5에서는 좀 더 구체적이고 보호자처럼 이끌어주는 프롬프트**가 효과적이고, GPT-4는 상대적으로 **간결한 지시만으로도 맥락을 잘 파악**하는 편입니다. 그리고 어떤 모델이든 **제한 사항(지식 컷오프 시점, 금지된 주제 등)**은 존재하니, 모델의 한계를 넘는 답을 기대하기보다는 필요한 경우 프롬프트에 최신 정보를 제공하거나 적절한 대안을 찾는 것이 중요합니다.

## 4. 동일 프롬프트에 대한 예측 불가능성 대응 방안

프롬프트 엔지니어링에서 난관 중 하나는 **일관성 유지**입니다. 특히 **동일한 프롬프트라도 모델의 버전 업그레이드나 내부 변경으로 인해 응답이 달라질 수 있는 예측 불가능성**이 존재합니다. 이러한 변화에 대비하고 대응하는 방법을 살펴보겠습니다.

- **모델 업그레이드 변화 모니터링:** AI 서비스 측에서 모델을 개선하거나 업데이트하면, 이전에는 잘 되던 프롬프트가 갑자기 기대와 다른 결과를 낼 수 있습니다. 이를테면 OpenAI의 ChatGPT도 주기적으로 업그레이드되어, 톤이나 스타일이 미세하게 변하거나 시스템 명령을 해석하는 방식이 바뀐 사례들이 있었습니다. **이러한 변화를 모니터링하는 것이 첫걸음**입니다. 가능한 경우 모델의 버전 정보를 명시적으로 지정하여 사용하는 것이 좋습니다 (예: API에서 `gpt-3.5-turbo-0613`처럼 버전 고정). 그래야 의도치 않은 업그레이드로 인한 변화 없이 **일관된 동작을 유지**할 수 있습니다. 만약 버전을 고정할 수 없다면, 주기적으로 AI 응답을 검수하고 변화 조짐이 있는지 살피는 것이 필요합니다.

- **프롬프트의 견고성 강화:** 프롬프트를 작성할 때 **특정 모델의 quirks(버그나 기묘한 행동)**에 의존한 설계를 피합니다. 예를 들어 어떤 표현은 이전 버전 모델의 약점을 우회하기 위한 것이었는데, 업그레이드 후에는 오히려 부자연스러울 수 있습니다. 가능한 한 **일반적인 원칙에 맞는 프롬프트**로 작성하여, 모델이 바뀌어도 해석이 크게 달라지지 않도록 합니다. 또한 **중요 지침을 이중으로 강조**하는 등 여유를 두는 것도 방법입니다. (예: *“다음 답변은 반드시 3문장으로 구성하세요 (중요!)”*처럼 표시). 새로운 모델이 나와도 이 지침을 무시하지 않도록 하는 안전장치인 셈입니다. 프롬프트에 핵심 요구사항을 여러 방식으로 언급하면 한두 곳을 모델이 간과하더라도 다른 표현을 통해 인지할 수 있습니다.

- **테스트와 검증 프로세스:** 제품이나 업무에 프롬프트를 활용하는 경우라면, **프롬프트에 대한 테스트 케이스와 검증 절차**를 마련해 두는 것이 좋습니다. 예컨대 몇 가지 대표 입력에 대한 출력 예시를 저장해 두고, 모델이 업데이트된 후 그 프롬프트를 다시 실행해보는 것입니다. 예상 출력과 달라진 점이 없는지 비교함으로써 변화 여부를 빠르게 파악할 수 있습니다. 만약 변화가 발견되면, **프롬프트를 수정하거나 모델 설정을 조정**하여 원래 의도한 결과를 복원하도록 대응합니다. 프롬프트 자체에도 버전 개념을 두어, 언제 어떤 변경을 가했는지 기록해두면 추후 문제 해결에 도움이 됩니다. 실제로 현업에서는 이러한 **프롬프트 버전 관리와 롤백 전략**이 중요합니다. 모델의 응답 변화로 새로운 오류나 성능 저하가 발생할 경우, 이전 버전 프롬프트로 쉽게 돌아갈 수 있도록 해두는 것입니다 ([From Prompt to Production — LLMops with LLMP | by Lukasz Kowejsza | Medium](https://medium.com/@lukas.kowejsza/from-prompt-to-production-llmops-with-llmp-480faa02422e#:~:text=3,introduce%20new%20errors%20or%20underperform)).

- **무작위성 통제:** 모델 응답의 예측 불가능성에는 업그레이드 외에도 **내부 생성의 무작위성**도 있습니다. 특히 OpenAI API를 사용할 때 `temperature`나 `top_p` 등의 파라미터가 높게 설정되면 같은 프롬프트라도 매 번 다른 답을 내놓습니다. ChatGPT 인터페이스에서는 이러한 파라미터를 직접 조절할 순 없지만 기본적으로 어느 정도 무작위성이 존재합니다. 따라서 중요한 건마다 답이 달라지면 곤란한 경우, **프롬프트를 최대한 명확히 하여 해석의 여지를 줄이고**, 필요하면 후속 질문으로 **검증**합니다. 예를 들어 첫 답변이 조금이라도 다를 수 있으면 *“위 답변을 한 문장으로 요약하면?”* 등 후속 프롬프트로 **형식을 통일**할 수 있습니다. 또한 API 사용 시에는 `temperature=0`처럼 설정하여 응답을 **디터미니스틱(deterministic)**하게 만드는 것이 한 방법입니다 ([Mastering Prompt Engineering: Best Practices, Do's and Don'ts](https://www.linkedin.com/pulse/mastering-prompt-engineering-best-practices-dos-donts-lucca-sehn-nmiqf#:~:text=4,Parameters)). 무작위성을 낮추면 매번 비슷한 출력이 나오므로 업그레이드 전에 기대했던 형태를 유지하기 쉽습니다.

- **사용자 피드백과 지속적 개선:** 일반 사용자 입장에서 모델의 변경을 모두 예측할 수는 없습니다. 따라서 변동이 발생하면 그것을 **학습 기회로 삼아 프롬프트를 더욱 개선**하는 것이 장기적으로 도움이 됩니다. 예컨대 모델이 업데이트되며 어투가 조금 바뀌었다면, 프롬프트에 원하는 어투를 직접 명시해서 원래 스타일을 유지하게 만들 수 있습니다. 또는 새로운 모델의 장점(더 많은 지식, 긴 컨텍스트 등)을 활용하도록 프롬프트를 확장할 수도 있습니다. **유연성과 적응력**을 가지고 프롬프트를 다듬어 나가면, 모델이 발전하더라도 그에 맞춰 더 나은 결과를 얻을 수 있을 것입니다.

요약하면, **프롬프트에 대한 예측 불가능성**은 완전히 없앨 수는 없지만, **명확한 지시와 체계적인 관리**로 줄일 수 있습니다. 모델의 변화를 주시하고, 프롬프트를 지속적으로 테스트하며, 필요시 수정과 롤백을 병행하세요. 이런 노력이 쌓이면 어떤 모델을 만나도 비교적 안정적인 성능을 끌어낼 수 있습니다.

## 5. 실패하기 쉬운 프롬프트 예시와 개선 방안

마지막으로, **잘못된 프롬프트**의 사례 몇 가지를 살펴보고 더 나은 대안을 제시합니다. 이는 앞서 논의한 원칙들을 실전에 적용하는 연습이 될 것입니다.

- **모호한 요청** – 예시: *“글 좀 써줘.”* (어떤 글을 얼마나 어떻게 써야 하는지 전혀 특정하지 않음).
  **→ 개선:** *“IT 업계의 최신 동향을 주제로 3단락 분량의 보고서를 작성해줘.”*
  *분석:* 막연히 “글 써달라”는 요청은 모델이 방향을 잡기 어렵습니다. 반면 개선된 프롬프트처럼 **주제(IT 업계 최신 동향), 글의 형태(보고서), 분량(3단락)**을 명시하면 모델이 무엇을 해야 하는지 분명히 이해합니다 ([02-1 프롬프트 엔지니어링을 알아보자 - LLM을 활용한 코딩기초](https://wikidocs.net/270584#:~:text=,%EB%AA%85%ED%99%95%ED%95%98%EA%B2%8C%20%EC%A7%80%EC%A0%95%ED%95%98%EB%8A%94%20%EA%B2%83%EC%9D%B4%20%ED%9B%A8%EC%94%AC%20%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9E%85%EB%8B%88%EB%8B%A4)). 특히 한국어로 프롬프트를 작성할 때도 **구체적인 동사와 상세한 조건**을 달면 훨씬 효과적입니다 (예: *“비판적인 논조로 써줘”*, *“대화 형식으로 설명해줘”* 등) ([02-1 프롬프트 엔지니어링을 알아보자 - LLM을 활용한 코딩기초](https://wikidocs.net/270584#:~:text=,%EB%AA%85%ED%99%95%ED%95%98%EA%B2%8C%20%EC%A7%80%EC%A0%95%ED%95%98%EB%8A%94%20%EA%B2%83%EC%9D%B4%20%ED%9B%A8%EC%94%AC%20%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9E%85%EB%8B%88%EB%8B%A4)).

- **맥락 부족** – 예시: *“번역해줘.”* (무엇을 어떤 언어로 번역할지 언급 없음).
  **→ 개선:** *“다음 영어 문장을 한국어로 번역해줘: `I love programming.`”*
  *분석:* 원문이나 대상 언어 없이 “번역하라”는 지시는 실패합니다. 개선된 프롬프트는 **번역할 텍스트**와 **목표 언어(한국어)**를 제공하였습니다. 이처럼 **모델에 필요한 입력 정보와 맥락을 모두 주어야** 제대로 된 결과를 얻을 수 있습니다. 마찬가지로 요약 작업에서도 *“이거 요약해줘”*라고 하기보다, *“다음에 제시되는 글을 한 문장으로 요약해줘: [본문]”*처럼 맥락을 함께 주는 것이 필수입니다. 맥락이 충분하면 모델은 **추측하지 않고** 정확히 주어진 내용만 처리합니다.

- **출력 형식 미지정** – 예시: *“다음 기사 내용 알려줘.”* (어떤 형태로 알려줄지 불분명).
  **→ 개선:** *“다음 기사의 핵심 내용을 **세 줄 요약**해줘.”* 또는 *“다음 기사 내용을 **한글 5개 항목 bullet point**로 정리해줘.”*
  *분석:* 첫 프롬프트는 그냥 내용을 풀어서 이야기할지, 요약할지, 분석할지 모델이 판단해야 하므로 일관된 대응이 어렵습니다. 개선안은 **요약으로 할 것**과 **세 줄로 제한**하거나 **불릿 목록 형식**으로 정리하도록 명확히 명시했습니다. 실제 실험에서도 “간단히 요약해줘”라고만 할 때보다 “2문장으로 요약해줘”처럼 **형식과 분량을 구체적으로 지정**하면 더 간결하고 핵심적인 요약을 얻을 수 있었습니다 ([Compilation of prompt engineering basic rules : r/ChatGPTPromptGenius](https://www.reddit.com/r/ChatGPTPromptGenius/comments/13vyz0u/compilation_of_prompt_engineering_basic_rules/#:~:text=Summarize%20the%20following%20news%20article%3A)). 이렇듯 원하는 **응답의 틀**을 알려주면 모델은 그 요구에 맞춰 답변을 구조화합니다.

- **부정형 지시** – 예시: *“여기 오류가 있을 수도 있으니, 오류가 있으면 출력하지 마.”*
  **→ 개선:** *“오류가 발생하면 '**오류: ...**' 형식으로 알려줘.”*
  *분석:* *“~하지 마”*라는 부정 지시는 모델이 이를 무시하고 진행해버리거나, 아예 아무 응답도 안 하는 등 문제를 일으킬 수 있습니다. 대신 개선된 예시처럼 **오류 시 어떻게 해야 하는지 긍정적으로 지시**하는 편이 안전합니다. 이처럼 *“포함하지 마”*보다는 *“~만 포함해”*, *“무시해”*보다는 *“어떻게 대응해”*로 바꿔 말하는 것이 바람직합니다 ([11 prompting tips to make GPT-3.5 as good as GPT-4](https://www.vellum.ai/blog/prompt-engineering-tips-to-boost-gpt-3-5-to-gpt-4-level#:~:text=Summarize%20the%20main%20ideas%20of,not%20present%20in%20the%20text)). 예를 들어, *“개인정보가 있다면 출력하지 마”*보다는 *“개인정보를 마스킹(✕✕처리)해서 출력해”*라고 하는 식입니다. 이렇게 하면 모델이 금지된 행동을 피하면서도 무엇을 해야 하는지 분명히 알게 됩니다.

위 개선 방안을 통해, 잘못된 프롬프트로 인한 실패를 줄이고 **모델에게 원하는 바를 정확히 전달**할 수 있습니다. 항상 프롬프트를 작성한 뒤에는 **“내가 AI라면 이 요청을 보고 무엇을 해야 할지 바로 알 수 있는가?”** 자문해보세요. 만약 해석의 여지가 남아 있다면 프롬프트를 다듬어서 더 명확히 만드는 것이 좋습니다. 프롬프트 엔지니어링은 작은 표현 차이 하나로도 결과가 달라질 수 있으므로, 위에서 살펴본 모범 사례들을 참고하여 꾸준히 연습하고 최적화해보세요. **명확한 지침, 충분한 맥락, 적절한 예시와 형식 제시**가 어우러진 프롬프트는 한국어 작업에서도 높은 성능과 신뢰도 있는 AI 응답을 이끌어낼 것입니다.

사용자와 AI 모델 간의 소통을 원활하게 하는 프롬프트 엔지니어링은 **시대의 새로운 문해력**이라고 불리기도 합니다. 잘 설계된 프롬프트를 통해 원하는 정보를 얻고, 창의적인 협업을 이루며, AI를 더욱 유용하게 활용하시길 바랍니다.

**참고자료:** 프롬프트 엔지니어링 팁 모음 ([프롬프트 엔지니어링이란 무엇인가요? (기본 사항 및 모범 사례)](https://textcortex.com/ko/post/what-is-prompt-engineering#:~:text=%EC%A7%81%EC%A0%91%EC%A0%81%EC%9D%B4%EA%B3%A0%20%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0%20%EC%89%AC%EC%9A%B4%20%EC%A7%80%EC%B9%A8%20%EB%A7%8C%EB%93%A4%EA%B8%B0)) ([프롬프트 엔지니어링이란? - AI 프롬프트 엔지니어링 설명 - AWS](https://aws.amazon.com/ko/what-is/prompt-engineering/#:~:text=%EB%AA%A8%ED%98%B8%ED%95%98%EC%A7%80%20%EC%95%8A%EC%9D%80%20%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8)), OpenAI 및 AWS 프랙티스 가이드 ([프롬프트 엔지니어링이란? - AI 프롬프트 엔지니어링 설명 - AWS](https://aws.amazon.com/ko/what-is/prompt-engineering/#:~:text=%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8%20%EB%82%B4%EC%9D%98%20%EC%A0%81%EC%A0%88%ED%95%9C%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8)) ([프롬프트 엔지니어링이란 무엇인가요? (기본 사항 및 모범 사례)](https://textcortex.com/ko/post/what-is-prompt-engineering#:~:text=%EC%A7%80%EC%86%8D%20%EA%B0%80%EB%8A%A5%ED%95%9C%20%EC%97%90%EB%84%88%EC%A7%80%20%EC%86%94%EB%A3%A8%EC%85%98%EC%9D%84%20%EC%A3%BC%EC%A0%9C%EB%A1%9C,%EC%B6%9C%EB%A0%A5%20%ED%98%95%EC%8B%9D%EC%9D%80%20%EB%B6%88%EB%A6%BF%ED%8F%AC%EC%9D%B8%ED%8A%B8%20%EB%AA%A9%EB%A1%9D%EC%9D%B4%EC%96%B4%EC%95%BC%20%ED%95%A9%EB%8B%88%EB%8B%A4)), 다양한 사례 분석 (Prompting Guide, Vellum AI 등) ([11 prompting tips to make GPT-3.5 as good as GPT-4](https://www.vellum.ai/blog/prompt-engineering-tips-to-boost-gpt-3-5-to-gpt-4-level#:~:text=8)) ([11 prompting tips to make GPT-3.5 as good as GPT-4](https://www.vellum.ai/blog/prompt-engineering-tips-to-boost-gpt-3-5-to-gpt-4-level#:~:text=First%20and%20foremost%2C%20your%20prompt,needs%20to%20be%20very%20specific)), 한국어 프롬프트 활용 블로그 자료 ([02-1 프롬프트 엔지니어링을 알아보자 - LLM을 활용한 코딩기초](https://wikidocs.net/270584#:~:text=,%EB%AA%85%ED%99%95%ED%95%98%EA%B2%8C%20%EC%A7%80%EC%A0%95%ED%95%98%EB%8A%94%20%EA%B2%83%EC%9D%B4%20%ED%9B%A8%EC%94%AC%20%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9E%85%EB%8B%88%EB%8B%A4)), 모델 버전 비교 자료 ([GPT-3.5 vs. GPT-4: Biggest differences to consider | TechTarget](https://www.techtarget.com/searchenterpriseai/tip/GPT-35-vs-GPT-4-Biggest-differences-to-consider#:~:text=GPT,extended%20capabilities%20include%20the%20following)) ([Comparing GPT-3.5 & GPT-4: A Thought Framework on When To Use Each Model](https://techcommunity.microsoft.com/blog/azure-ai-services-blog/comparing-gpt-3-5--gpt-4-a-thought-framework-on-when-to-use-each-model/4088645#:~:text=analysis%2C%20and%20classification%20workloads,learning%2C%20which%20use%20more%20tokens)).